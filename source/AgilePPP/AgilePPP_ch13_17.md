## 薪水支付案例研究

---

> 研究一个批量(batch)处理薪水支付系统的设计和实现。在设计实现中我们会使用到不同的设计模式。
> COMMAND , TEMPLATE METHOD , STRATEGY , NULL OBJECT . FACTORY 以及 FACADE 。

### COMMAND 模式和 ACTIVE OBJECT 模式

command 模式是很简单的，在command类中封装了一个没有任何变量的函数。然后由对应的命令进行绑定对应的操作函数的实现。当对端接收到一个命令时，它不需要关心是什么命令，只需要执行该命令所绑定的函数方法即可。

实现实体上的解耦和时间上的解耦，在实体上解耦就是将命令操作过程中的命令验证和命令执行分离开。在时间上解耦是在将验证和执行分离开之后，可以实现当场验证和在规定时间内执行的需求。

在command模式中添加undo()方法，如果do()方法可以记住它所执行的细节，那么undo()方法就可以取消这些操作并把系统恢复到原先状态。

active object 模式可以实现多线程控制。可以通过维护command对象的链表进行执行每个命令。通过使用RTC任务可以使command实例不会阻塞。

command模式是非常有用的。


### TEMPLATE METHOD 模式和 STRATEGY 模式 ：继承与委托

template method 模式使通过将通用算法放在基类中，然后再根据不同的场景进行实现具体功能接口。

strategy 模式是将通用算法放进一个具体类中，然后将通用算法需要调用的抽线方法定义到一个接口中，然后再派生出不同场景需要的类。

template method 模式和 strategy 模式都可以用来分离高层的算法和底层的具体实现细节。都允许高层的算法独立于他的具体实现细节重用。此外，strategy 模式也允许具体实现细节独立于高层的算法重用。不过要以一些额外的复杂性，内存以及运行时间开销作为代价。


### FACADE 模式和 MEDIATOR 模式

facade 模式适用于为一组具有复杂且全面的接口对象体提供一个简单且特定的接口的时候。facade模式是以明显且受限的方式来施加它的策略。而 mediator 模式是以隐藏且不受限的方式施加他的策略。

如果策略涉及范围广泛且可见，那么可以使用facade模式从上面施加策略。另一方面，如果策略隐蔽且有针对性，那么mediator 模式是更好的选择。

### SINGLETON 模式和 MONOSTATE 模式

一般情况下，类与对象是一对多的关系，但是有些类只有一个对象，这种对象是应用程序的基础（root）对象。通过基础对象可以得到系统中其他对象，如：工厂对象，用来创建系统中其他对象。管理器对象，负责管理系统中的其他对象。

强制对象的单一性模式：单例模式（singleton）和单态模式（monostate）

singleton模式使用私有构造函数，一个静态变量，以及一个静态方法对实例化进行控制和限制。

mono state模式只是简单的把对象的所有变量变成静态的。

如果希望透过派生去约束一个现存类，并且不介意他的所有调用者都必须要调用instance()方法来获取访问权，那么singleton模式是最合适的。如果希望类的单一性本质对使用者透明，或着希望使用单一对象的多态派生对象，那么mono state模式是合适的。

### NULL OBJECT 模式

那些长期使用C-base语言的人已经习惯于函数对某种失败返回NULL或0。我们认为对这样的函数返回值是需要检查的，NULL OBJECT模式则改变了这一点，使用这个模式，我们可以确保函数的返回值是一个有效的对象，即使是失败的时候，只不过代表失败的对象＂什么也不做＂。




