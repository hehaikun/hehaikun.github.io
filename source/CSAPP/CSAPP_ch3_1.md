
### 处理器发展历程  
计算机的发展是很迅猛的，短短的几十年，社会发生了天翻地覆的变化。这也离不开处理器芯片的高速发展。下面就简单的罗列一下处理器芯片的发展历程。  

    8086:           1978年，29K个晶体管  
    80286:          1982年，134K个晶体管  
	i386:           1985年，275K个晶体管  
	i486:           1989年，1.2M个晶体管  
	Pentium:        1993年，3.1M个晶体管  
	PentiumPro:     1995年，5.5M个晶体管  
	Pentium/MMX:    1997年，4.5M个晶体管  
	Pentium II:     1997年，7M个晶体管  
	Pentium III:    1999年，8.2M个晶体管  
	Pentium 4:      2000年，42M个晶体管  
	Pentium 4E:     2004年，125M个晶体管  
	Core 2:         2006年，291M个晶体管  
	Core i7:        2008年，781M~1,4G个晶体管  
	...



### 机器级代码
机器级的代码也就是汇编了，之前上学的时候学过一点ARM汇编，其实在Intel处理器上也都差不多。  
  
我们的C程序先是转换成汇编代码，然后才转换成机器指令，最后在机器上运行。  
x86-64的机器代码和C代码的差别也是相当大的，一些通常对C语言程序员隐藏的处理器状态都是可见的：  

- 程序计数器：给出将要执行下一条指令在内存中的地址。
- 整数寄存器包含16个命名位置，分别存储64位值。
- 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。
- 一组向量寄存器可以存放一个或多个整数或浮点数值。
  
关于Intel汇编的代码后缀如：  
  
	movl movw movq ...   
	字节：后缀为b 大小为1个字节  
	字  ：后缀为w 大小为2个字节  
	双字：后缀为l 大小为4个字节  
	四字：后缀为q 大小为8个字节  
	单精度：后缀为s 大小为4个字节  
	双精度：后缀为l 大小为8个字节  
  
### 访问信息

CPU包含有16个64位的通用目的寄存器。指令可以对16个寄存器的低位字节中的数据进行操作。在内存中存放的数据使用寻址操作。  
常见的数据寻址方式：  

- 立即(数)寻址
- 直接寻址
- 间接寻址
- 寄存器寻址
- 寄存器间接寻址
- 相对寻址
- 基址寻址
- 变址寻址
  
等各种寻址方式。  
这里注意一下立即数：直接出现在指令中的数，不用存储在寄存器或存储器中的数，每个立即数由一个8位的常数循环右移偶数位得到。

然后就是对数据的操作，加减乘除还有数据的搬移等操作，这些简单的操作支撑起整个工程的运行，不得不说真的很强大。

### 小结

CSAPP第三章主要讲的就是程序的机器级表示，看了前面这一小部分主要主要就是要理解程序具体是怎么执行的，程序的执行过程中，CPU到底干了些什么活。其实汇编语言才是真正的在操作CPU干活，汇编是执行效率最快的编程语言了，C语言也是先转换成汇编然后转换成机器指令码，所以C语言的执行效率很高就是这个原因。


