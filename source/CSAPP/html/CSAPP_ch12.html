<!DOCTYPE html><html><head><meta charset="utf-8"><title>CSAPP_ch12.md</title><style></style></head><body id="preview">
<h3><a id="_0"></a>并发编程</h3>
<p>定义：如果逻辑流在时间上重叠，那么他们就是并发。<br>
构建并发程序的基本方法：</p>
<ol>
<li>使用多进程实现并发</li>
<li>使用IO多路复用实现并发</li>
<li>使用多线程实现并发</li>
</ol>
<h4><a id="_8"></a>基于多进程的并发</h4>
<p>这是一种最简单的方式，使用fork exec 和 waitpid 之类的函数进行构造并发。<br>
这种方式有很大的弊端，进程间的相互独立，共享信息较困难，而且不能大量的并发，因为会消耗大量的资源。</p>
<h4><a id="IO_13"></a>基于IO复用的方式并发</h4>
<p>使用IO多路复用作为并发事件驱动，这是大型服务器常使用的方式。<br>
它运行在单一进程的上下文中，每个逻辑流都能访问该进程的全部空间地址，共享数据十分方便。<br>
并发过程中不需要切换上下文调度新的流，这使得系统很高效。<br>
现在的高性能服务器使用的都是基于IO多路复用的事件驱动编程方式，主要就是因为它有明显的性能优势。</p>
<h4><a id="_20"></a>基于多线程的并发</h4>
<p>因为线程是运行在进程的上下文中的逻辑流，他由内核自动调度，同时，一个进程的所有线程共享该进程的所有虚拟地址空间。<br>
线程的上下文小，切换消耗比进程要小，时间也更快。<br>
一个线程可以杀死他的任何对等线程，或者等待他的任何对等线程终止。</p>
<h4><a id="_26"></a>并发带来的竞争</h4>
<p>并发程序下，多个任务同时对一个数据操作就会出现不可预知的错误。因此就必须使用一种机制来实现多并发程序下任何可行轨迹都能正常工作。</p>
<p>使用信号量来同步线程。<br>
信号量可以实现互斥，实现对共享变量的互斥访问，这样的信号量也叫二元信号量。<br>
使用信号量可以调度共享资源。<br>
要注意不当的使用信号量会引入死锁的情况。</p>
<h4><a id="_35"></a>线程安全问题</h4>
<p>如果一个函数被称为线程安全，就是说它在被多个并发线程调用的时候，仍然能产生正确的结果。</p>
<p>线程不安全可以分为四类：</p>
<ol>
<li>不保护共享变量的函数</li>
<li>保持跨越多个调用状态的函数</li>
<li>返回指向静态变量的指针的函数</li>
<li>调用线程不安全函数的函数</li>
</ol>

</body></html>